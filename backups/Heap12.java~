/**
 * An implementation of the Heap data structue.
 *
 * @author Luke Cycon -- cs12fhr
 */
public class Heap12<E extends Comparable<? super E>> implements PQueue<E> {

    private Comparable[] array;
    private int size;

    /**
     * Contruct a new <code>Heap12</code> object with initial capacity of 5.
     */
    public Heap12(){
        array = new Comparable[5];
        size = 0;
    }

    /**
     * Construct a new <code>Heap12</code> object as a deep copy of another.
     */
    public Heap12(Heap12<E> o){
        array = new Comparable[o.array.length];
        System.arraycopy(o.array,0,array,0,o.array.length);
        size = o.size();
    }

    /**
     * Private to set internal array to the value passed to this contructor
     */
    private Heap12(E[] a){
        array = a;
        size = a.length;
    }

    /**
     * Add an element to this Heap.  Rebuilds the heap immediatley after to
     * ensure validity.
     *
     * @param e Object to add. Not <code>null</code>.
     *
     * @throws IllegalArgumentException if the argument is null
     */
    public void add(E e){
        if( e == null){
            throw new IllegalArgumentException("No null elements please");
        }
        if(size + 1 == array.length){
            Comparable[] temp = new Comparable[array.length * 2];
            System.arraycopy(array,0,temp,0,array.length);
            array = temp;
        }
        if(size == 0){
            array[0] = e;
            size++;
            return;
        }
        if(size == 1){
            array[1] = e;
            size++;
            bubbleUp(1);
            return;
        }

        // Must add one to size before calculating the right inner because
        // of Java's determination to round 3/2 to 1 and so forthh
        int rightInner = ((size + 1)/ 2) - 1;
        if(rightInner * 2 + 1 < size){
            array[rightInner * 2 + 2] = e;
            size++;
            bubbleUp(rightInner * 2 + 2);
        } else {
            array[rightInner * 2 + 1] = e;
            size++;
            bubbleUp(rightInner * 2 + 1);
        }
    }

    /**
     * Check to see if the Heap is empty. Heap remains unchanged after this
     * operation.
     *
     * @return true if the Heap is empty, false otherwise
     */
    public boolean isEmpty(){
        return size == 0;
    }

    /**
     * Examine the top element of the heap. The heap remains unchanged after
     * this operation.
     *
     * @return the element that would be retured by <code>remove()</code>
     */
    public E peek(){
        return (E) array[0];
    }

    /**
     * Remove the top element in the Heap. Rebuilds the heap immediatley
     * afterwards.
     *
     * @return the element removed
     */
    public E remove(){
        if(size == 1){
            Comparable temp = array[0];
            array[0] = null;
            size--;
            return (E) temp;
        }
        Comparable top = array[0];
        array[0] = array[size - 1];
        array[size - 1] = null;
        size--;
        trickleDown(0);
        return (E) top;
    }

    /**
     * Return the number of elements in the array.
     *
     * @return the number of elements in the array
     */
    public int size(){
        return size;
    }

    /**
     * Test if this object is equal to the parameter of the function. Returns
     * true when the sizes are equal and all element pairs correspond
     *
     * @param o The object to test for equality
     *
     * @return true if objects are equal, false if not
     */
    public boolean equals(Object o){
        // If this is a shallow copy, return true
        if(this == o){
            return true;
        }
        // Make sure we have a Heap12 object
        if(!(o instanceof Heap12)){
            return false;
        }
        Heap12 obj = (Heap12) o;
        if(size() != obj.size())
            return false;
        for(int i = 0; i < size(); i++){
            if(!array[i].equals(obj.array[i])){
                return false;
            }
        }
        return true;
    }

    /**
     * Implementation of a HeapSort using the Heap12 class.
     *
     * @throws NullPointerException if a is null
     */
    public static <T extends java.lang.Comparable<? super T>> void sort(T[] a){
        if(a == null)
            throw new NullPointerException();
        Heap12<T> heap = new Heap12<T>(a);

        int rightmost = ((heap.size + 1) / 2) - 1;

        for(int i = rightmost; i >= 0; i--){
            heap.trickleDown(i);
        }

    }

    /**
     * Perform the trickle down operation on an element in the heap.  Move
     * element down whenever it is smaller than the largest of its children.
     */
    private void trickleDown(int index){
        // Since all interior nodes are from 0 to size/2, we can do this
        while(index < size / 2){
            int left = index*2 +1;
            int right = index*2 +2;
            int largeChild = -1;

            // Left will always exist (Definition of a proper binary tree)
            // We need to check the right so though
            if(right < size && array[right].compareTo(array[left]) > 0){
                largeChild = right;
            } else {
                largeChild = left;
            }

            if(array[index].compareTo(array[largeChild]) < 0){
                Comparable temp = array[index];
                array[index] = array[largeChild];
                array[largeChild] = temp;
            } else {
                break;
            }

            index = largeChild;

        }

    }

    /**
     * Bubble up operation of heaps. Move the sekected element up the heap
     * whenever it is larger than its parent.
     */
    private void bubbleUp(int index){
        if(index >= size)
            throw new IllegalArgumentException();
        int parent = (index - 1) / 2;
        while(parent >= 0 && array[index].compareTo(array[parent]) > 0){
            Comparable temp = array[index];
            array[index] = array[parent];
            array[parent] = temp;
            index = parent;
            parent = (parent - 1) / 2;
        }
    }
}
