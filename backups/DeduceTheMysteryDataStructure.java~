import java.io.*;
import java.util.*;
import com.jake.*;

/**
  * P5
  *
  * Name: Adam William Kuipers        Student ID: A09511551
  */
public class DeduceTheMysteryDataStructure {
	private static final int NUM_DATA_STRUCTURES_TO_DEDUCE = 5;

	private static final String getCS12UserID () {
		final Map<String, String> env = System.getenv();
		return env.get("User");
	}

	public static void main (String[] args) throws IOException{
        File file;
        Writer output = null;
        int dataStructure;

		// You may want to hard-code cs12UserID to your CSE 12 user ID if you are developing on
		// a non-CSE-lab machine.
		final String cs12UserID = "cs12vax";	
		// final String cs12UserID = "cs12vZZ";  // Hard-coded instead
		System.out.println("My userID is set to: " + cs12UserID);

        // Variables
        final Random random = new Random();
        int N = 1;
        final int TRIALS = 1000;
        long start;
        boolean result;
        long end;
        long elapsed = 0;
        long totalTime;
        int randomInt;
        long elapsedTime = 0; // For add method, time total to add all trials.

		// Fetch the collections whose type you must deduce.
		// Note -- you are free to change the type parameter from Integer to whatever you want. In this
		// case, make sure to replace (over the next 4 lines of code) Integer with whatever class you prefer.
		// In addition, you'll need to pass the method getMysteryDataStructure a "sample" (an instance) of 
		// the class you want the collection to store.
		@SuppressWarnings("unchecked")
		final Collection12<Integer>[] mysteryDataStructures = (Collection12<Integer>[]) new Collection12[NUM_DATA_STRUCTURES_TO_DEDUCE];
		for (dataStructure= 0; dataStructure < NUM_DATA_STRUCTURES_TO_DEDUCE; dataStructure++) {

			mysteryDataStructures[dataStructure] = MysteryDataStructure.getMysteryDataStructure(cs12UserID, dataStructure, new Integer(0));

            System.out.println("Data Structure" + dataStructure);

            System.out.println("N\tT (contains(o))");
            file = new File("structure" + dataStructure + "contains.txt");
            // Test contains method of data structure 0
            output = new BufferedWriter(new FileWriter(file));
            for (int i = 1; i <= 100; i++) {
                N = i * 100;
                for (int j = 0; j < N; j++) {
                    mysteryDataStructures[dataStructure].add(new Integer(j));
                }

                // Element to find
                int elementToFind = random.nextInt(N); 
                // Find the average time to find the element
                for (int j = 0; j < TRIALS; j++) {
                    start = ArtificialClock.getNumTicks();
                    result = mysteryDataStructures[dataStructure].contains(N + elementToFind);
                    end = ArtificialClock.getNumTicks();

                    elapsedTime = elapsedTime + end - start;
                }
                
                //long totalTime = (elapsed / TRIALS);
                totalTime = elapsedTime / TRIALS;

                elapsedTime = 0; // clear elapsedTime

                System.out.println(N + "\t" + totalTime);
                output.write(N + "\t" + totalTime + "\n");

                // Clear data
                mysteryDataStructures[dataStructure].clear();
            }
            output.close(); 

            System.out.println("N\tT (add(o))");
            // Find the average time to find the element
            file = new File("structure" + dataStructure + "add.txt");
            // Test contains method
            output = new BufferedWriter(new FileWriter(file));
            for (int i = 1; i <= 100; i++) {
                N = i * 100;
                for (int j = 0; j < N; j++) {
                    mysteryDataStructures[dataStructure].add(new Integer(random.nextInt(N)));
                }
                
                randomInt = new Integer(random.nextInt(N));
                for (int j = 0; j < TRIALS; j++) {
                    start = ArtificialClock.getNumTicks();
                    mysteryDataStructures[dataStructure].add(N + randomInt);
                    end = ArtificialClock.getNumTicks();

                    // Remove recently added element.
                    mysteryDataStructures[dataStructure].remove(N + randomInt);

                    elapsedTime = elapsedTime + end - start;
                }

                totalTime = (elapsedTime / TRIALS);
                elapsedTime = 0; // clear elapsedTime
                System.out.println(N + "\t" + totalTime);
                output.write(N + "\t" + totalTime + "\n");
                // Clear data
                mysteryDataStructures[dataStructure].clear();
            }
            output.close();
        
    }
}
