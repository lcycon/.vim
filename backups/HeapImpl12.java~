import java.util.*;
import java.lang.*;

class HeapImpl12<T extends Comparable<? super T>> implements Heap12<T> {
    T _underlyingStorage[]; // The array to hold the children of each node.
    T _nodeArray[]; // The array to hold each node
    private static final int CAP = 128; // Number of nodes.
    private int _size;
    private int _children;

    /**
     * Parameterized constructor
     * Allows user to input the number of children that each node will have.
     * @param d The number of children each node will have.
     * @throws IllegalArgumentException
     */
    @SuppressWarnings("unchecked")
	public HeapImpl12(int d) throws IllegalArgumentException {
        if (d < 2) {
            throw new IllegalArgumentException();
        }
        _nodeArray = (T[]) new Comparable[CAP];
        _size = 0;
        _children = d;
    }
        _nodeArray = new T[CAP];
        

	/** Removes all elements from the heap. */
    @Override
	public void clear () {
        for (int i = 0; i <= size(); i++) {
            _nodeArray[i] = null;
        }
        _size = 0;
    }

	/** Adds the specified element to the heap.
	  * Must take O(log n) time (worst-case) for a heap of n elements.
	  * @param o the element to add.
	  */
    @Override
    public void add(T o) {
        if (size() == _nodeArray.length) {
            doubleCapacity();
        }
        _nodeArray[size()] = o;
        bubbleUp(size());
        _size++;
    }

	/** Returns the number of elements (null or otherwise) currently stored in the
	  * heap.
	  * @return the number of elements stored in the heap.
	  */
    @Override
    public int size() {
        return _size;
    }

	/** Returns (but does not remove) the largest element currently stored in the heap.
	  * Must take O(1) time (worst-case) for a heap of n elements.
	  * @return the largest element stored in the heap.
	  */
    @Override
    public T peekLargest() throws NoSuchElementException {
        if (size() == 0) {
            throw new NoSuchElementException();
        }
        return _nodeArray[0];
    }

	/** Removes and returns the largest element currently stored in the heap.
	  * If the heap is empty, then this method throws a 
	  * <tt>NoSuchElementException</tt>.
	  * Must take O(log n) time (worst-case) for a heap of n elements.
	  * @throws NoSuchElementException
	  * @return the largest element stored in the heap.
	  */
    @Override
    public T removeLargest() throws NoSuchElementException{
        if (size() == 0) {
            throw new NoSuchElementException();
        }
        T largest = peekLargest();
        _nodeArray[0] = _nodeArray[size() - 1];
        _nodeArray[size() - 1] = null;
        _size--;
        if (size() > 0) {
            trickleDown(0);
        }
        return largest;
    }

	/** If <tt>o</tt> is contained in the heap, then this method return the height of any arbitrary element
	  * of the heap that is equal to <tt>o</tt> (in the <tt>equals</tt> sense).
	  * Height is defined so that the root of the heap (i.e., the largest element) should have height
	  * 0; any child of the root should have height 1; any child of a child of the root should have height 2;
	  * and so on.
	  * Must take O(log n) time (worst-case) for a heap of n elements.
	  * @param o the element whose height is to be returned
	  * @throws NoSuchElementException
	  */
    @Override
	public int height (T o) throws NoSuchElementException {
        int i = find(o); // Index where object is
        int height = 0; // Depth of tree from location.
        if (i == -1) {
        	throw new NoSuchElementException();
        }
        while (i > 0) {
            i = getParent(i);
            height++;
        }
      //  int height = (int) (Math.log (i + 1) / Math.log(_children) + 1);
        return height;
    }

	/** If <tt>o</tt> is contained in the heap, then this method removes any arbitrary element
	  * of the heap that is equal to <tt>o</tt> (in the <tt>equals</tt> sense).
	  * If <tt>o</tt> is not contained in the heap, then the method throws a
	  * <tt>NoSuchElementException</tt>.
	  * May take O(n) time (worst-case) for a heap of n elements.
	  * @param o the element to remove
	  * @throws NoSuchElementException
	  */
    @Override
	public void remove (T o) throws NoSuchElementException {
        int index = find(o); // Index where object is located;
        if (index == -1) {
        	throw new NoSuchElementException();
        }
        _nodeArray[index] = _nodeArray[size() -1];
        _nodeArray[size() -1] = null;
        _size--;
        if (size() > 0 && index < size()) {
            trickleDown(index);
        }
    }


	/** Returns whether or not the heap contains the specified element.
	  * May take O(n) time (worst-case) for a heap of n elements.
	  * @param o the element we wish to check
	  * @return whether <tt>o</tt> is stored in the heap.
	  */
    @Override
	public boolean contains (T o) {
        boolean found = false; // Whether optect is found or not.
        for (int i = 0; i < _size && found == false; i++) {
            if (_nodeArray[i].equals(o)) {
                found = true;
            }
        }
        return found;
    }

    /**
     * Helper method to double the capacity of the array when the array 
     * becomes full.
     */
	@SuppressWarnings("unchecked")
    private void doubleCapacity() {
        T[] old = _nodeArray;
        int length = _nodeArray.length;
        _nodeArray = (T[]) new Comparable[length + CAP];
        for (int i = 0; i < length; i++) {
            _nodeArray[i] = old[i];
        }
    }

    /** 
     * Helper method to find the first node, from node index, that contains 
     * user specified object. If find returns -1, node not found.
     * @param o User specified object.
     * @param index Where to check children from
     * @return Node index of where to start from.
     */
    private int find(T o) {
        int node = -1; // Where object is located.
        boolean found = false; // Whether object is found or not.
        for (int i = 0; i <= size() && found == false; i++) {
            if (_nodeArray[i].equals(o)) {
                found = true;
                node = i;
            }
        }

        return node;
    }

    /**
     * Helper method to return the index of the parent of the current node.
     * @param i Node who's parent we find.
     * @return Index of parent node.
     * @throws IllegalArgumentException
     */
    private int getParent(int i) throws IllegalArgumentException{
        if (i < 0) {
            throw new IllegalArgumentException();
        }
        if (i == 0) {
            return 0;
        }
        return (i - 1) / (_children);
    }

    /**
     * Method to balance the heap
     * @param index Index of node to bubble
     */
    private void bubbleUp (int index) {
        if (index > 0) {
            T temp;
            int parent = getParent(index);
            while (_nodeArray[index].compareTo(_nodeArray[parent]) > 0 && index > 0) {
                temp = _nodeArray[parent];
                _nodeArray[parent] = _nodeArray[index];
                _nodeArray[index] = temp;
                index = parent;
                if (index > 0) {
                    parent = getParent(index);
                }
            }
        }
    }

    /**
     * Helper method to move a node that is too small, down the heap
     * @param index from where we trickle down.
     * @throws IllegalArgumentException
     */
	private void trickleDown(int index)throws IllegalArgumentException{
        if (_nodeArray[index] == null) {
            throw new IllegalArgumentException();
        }
        T node;
        for (int i = index + 1; _nodeArray[i] != null && i <= index + _children; i++) {
            if (_nodeArray[index].compareTo(_nodeArray[i]) < 0) {
                node = _nodeArray[i];
                _nodeArray[i] = _nodeArray[index];
                _nodeArray[index] = node;
                trickleDown(i);
            } 
        }
    }

    /**
     * Printer method for testing
     */
    public void print() {
        System.out.println("Children: " + _children);
        for (int i = 0; i < size(); i++) {
            System.out.println(_nodeArray[i]);
        }
    }
}
