/**
 * Project 3
 * Queue Implementation with a Ring Buffer
 * @author Adam William Kuipers
 * @version 2011.08.20.01
 */
import java.util.NoSuchElementException;

class QueueImpl12<T> implements Queue12<T> {
     private int _capacity; // The capacity of the ring buffer.
     private int _size; // The number of elements in the ring buffer.
     private int _first; // The first element in the queue (First to be removed)
     private int _last; // The last element in the queue (Last to be removed)
     private T[] _ringBuffer; // The array of object T

    /**
     * Default Constructor
     * Sets _capacitiy to 128.
     */
    public QueueImpl12() {
        _capacity = 128;
        _ringBuffer = (T[]) new Object[_capacity];
        _size = 0;
        _first = 0; // _first starts at beginning of array.
        _last = 0; // The first enqueue will insert into the first of the array.
    }

    /**
     * Constuctor
     * Sets the size of the array to user specification
     * @param c The _capacity.
     * @throws IllegalArgumentException if the user inputs a negative value
     */
    public QueueImpl12(int c) throws IllegalArgumentException{
        if (c < 0) {
            throw new IllegalArgumentException();
        }
        _capacity = c;
        _ringBuffer = (T[]) new Object[_capacity];  
        _size = 0;
        _first = 0; // _first starts at beginning of array.
        _last = 0; // The first enqueue will insert into the first of the array.
    }

    /**
     * Removes all elements from the queue.
     */
    @Override
    public void clear() {
        while (_first <= _last) {
            dequeue();
        }
        _size = 0;
        _first = 0;
        _last = 0;
    }

	/** 
     * Returns the <em>capacity</em> of the queue, i.e., the
     * maximum number of elements that can be stored in the queue.
     * The capacity of the queue is equivalent to the size of the Java array used
     * to implementor the ring buffer (the underlying storage of the queue).
     * @return the capacity of the queue. 
     */
    @Override
    public int capacity() {
        return _capacity;
    }

	/** 
     * Returns the number of elements (<tt>null</tt> or otherwise) currently stored in the
	 * queue.
	 * @return the number of elements stored in the queue.
	 */
    @Override
    public int size() {
        return _size;
    }

	/**
     * Attempts to add the specified element <tt>o</tt> to the <em>back</em> of the queue.
     * The attempt will fail if, and only if, the queue's size is already equal to its
     * capacity. <tt>o</tt> may be <tt>null</tt>. This method must run in time O(1) worst-case.
	 * @param o the object to be enqueued.
     * @return whether the attempt to add was successful.
	 */
    @Override
    public boolean enqueue(T o) {
        boolean bool = false; // whether the enqueue is done or not
        if (_size < _capacity) {
            _ringBuffer[_last] = o;
            _size++;
            _last = (_last + 1) % _capacity; // Wrap arround ring buffer.
            bool = true;
        }
        return bool;
    }

	/** 
     * Removes and returns the object stored at the <em>front</em> of the queue.
     * This method must run in time O(1) worst-case.
     * @return the element that was just removed from the front of the queue.
	 * @throws NoSuchElementException if the queue is empty.
     */
    @Override
	public T dequeue () throws NoSuchElementException {
        if (_size == 0) {
            throw new NoSuchElementException();
        }
        T temp = peek();
        _ringBuffer[_first] = null; // Remove element
        _size--; // Decrement size
        _first = (_first + 1) % _capacity; // Wrap arround ring buffer.
        return temp;
    }

	/** 
     * Returns the object stored at the <em>front</em> of the queue.
     * @return the object that is currently stored at the front of the queue.
	 * @throws NoSuchElementException if the queue is empty.
     */
    @Override
	public T peek () throws NoSuchElementException {
        if (_size == 0) {
            throw new NoSuchElementException();
        }
        return _ringBuffer[_first];
    }

    /**
     * Prints every element in the array.
     */
    public void print() {
        T temp;
        while (temp <= _last) {
            temp = dequeue();
            System.out.println(temp);
            temp++;
        }
    }
}
